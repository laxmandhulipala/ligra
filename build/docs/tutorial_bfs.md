---
id: tutorial_bfs
sectionid: docs
layout: docs
title: "Tutorial: Breadth-First Search"
next: tutorial_kcore.html
prev: getting_started.html
redirect_from: "docs/index.html"
---

In this project, we'll implement a parallel version of Breadth-First Search in 
Ligra. Given a graph, $G = (V,E)$, and a source node $s$, a Breadth-First Search 
processes the graph level by level, starting from $s$. The output of the 
algorithm is an array $A$ s.t. $\forall v \in V, A[v]$ holds the parent of $v$ in 
the *breadth-first tree* rooted at $s$. 

### Writing generic graph algorithms

One of the main goals of Ligra is to abstract away implementation specific details
about how the graph is represented (Is the graph compressed/uncompressed? Is it
directed/undirected?). The standard way of implementing an algorithm in Ligra is 
to implement a method, `Compute`, which has the following signature: 

``` cpp
template <class vertex>
void Compute(graph<vertex>& G, commandLine P);
```

To get started, open up a new file in the `apps/` directory, `Tutorial_BFS.C`, and 
enter in the following stub. The only include we will require is the `ligra.h` header
file.

``` cpp
#inclde "ligra.h"

template <class vertex>
void Compute(graph<vertex>& G, commandLine P) {
  long start = P.getOptionLongValue("-start",0);
  long n = GA.n;
  //creates Parents array, initialized to all -1, except for start
  long* Parents = new long[n];
  parallel_for(long i=0;i<n;i++) Parents[i] = -1;
  Parents[start] = start;
}
```

So far, we have set up the variables and data necessary for the algorithm. 
We use the `parallel_for` to initialize memory in parallel. This statement 
is just a macro that is replaced by either a parallel loop if we are using 
MPI or Cilk, or a standard for loop if MPI or CILK is unavailable. Note that 
all memory we allocate in the body of `Compute`  must be explicitly freed 
in order to prevent memory leaks.

Next, we will discuss how to represent frontiers in the BFS and process them. 

### Representing a frontier

We can express a frontier generated by the BFS with the **`vertexSubset`** datatype in 
Ligra, which allows us to represent a subset of the vertices. Each level of the 
traversal will be represented by a `vertexSubset`. The initial `vertexSubset`, with is just
a set containing our source node can be constructed the following constructor

``` cpp
vertexSubset Frontier(n, source); // creates initial frontier
```
add this line to the end of the `Compute` function. 

### Traversing a frontier

Now, we need to describe the logic to produce the next frontier given the current frontier.
Enter **`edgeMap`**. `edgeMap` allows us to process the out edges of a `vertexSubset`,
and produce a new `vertexSubset`. The function has the following signature:

``` cpp
template <class vertex, class F>
inline vertexSubset edgeMap(graph<vertex> GA, vertexSubset &V, F f);
```

The behavior of `edgeMap` can be customized by providing a user-defined `F`

expects a parameter of some template class `F` that has the following fields: 

``` cpp
struct F {
  F(...) { ... }
  inline bool update (long s, long d) {
    // logic for how to process the edge (s,d)
    // return 1 if d should be included in the returned vertexSubset
    // return 0 otherwise
  }

  inline bool cond (long d) {
    // return 1 if update should be applied on and edge (s,d) 
    // return 0 otherwise
  }
};
```

Note that the `update` logic must be atomic. If a vertex has more than one
in-edge from the current frontier, then multiple calls to `update` can 
happen in parallel which may result in an incorrect result.

For BFS, we will implement a struct, `BFS_F` that 

- `update`: atomically update `Parents` array. We can implement this using a
  compare and swap operation. A simple, implementation independent version
  is provided by the framework as `CAS` in `ligra/utils.h`.  
- `cond`: avoid revisiting previously visited vertices.

``` cpp
struct BFS_F {
  long* Parents;
  BFS_F(long* _Parents) : Parents(_Parents) {}
  inline bool update (long s, long d) { // atomically update
    return (CAS(&Parents[d],(long)-1,s));
  }
  //cond function checks if vertex has been visited yet
  inline bool cond (long d) { return (Parents[d] == -1); }
};
```

Add this code before the definition of `Compute`. 

Notice that while `BFS_F` will correctly produce the next frontier, the tree computed 
by the BFS is still non-deterministic! We will discuss how to fix this in a later section.

### Implementing traversal logic

All we need to do to finish up the BFS is to actually call `edgeMap`, and
add a termination condition that signifies when the traversal is finished. Given
a current frontier, our condition should just apply the edgeMap while the current
frontier is non-empty. In code:

``` cpp
while(!Frontier.isEmpty()){ //loop until frontier is empty
  vertexSubset output = edgeMap(GA, Frontier, BFS_F(Parents));
  Frontier.del();
  Frontier = output; //set new frontier
}
```

### The final algorithm

The last step is to just free any memory allocated in the body of `Compute`. Our
finished BFS algorithm should look as follows:

``` cpp
#include "ligra.h"

struct BFS_F {
  long* Parents;
  BFS_F(long* _Parents) : Parents(_Parents) {}
  inline bool update (long s, long d){ //atomic version of Update
    return (CAS(&Parents[d],(long)-1,s));
  }
  //cond function checks if vertex has been visited yet
  inline bool cond (long d) { return (Parents[d] == -1); }
};

template <class vertex>
void Compute(graph<vertex>& GA, commandLine P) {
  long start = P.getOptionLongValue("-r",0);
  long n = GA.n;
  //creates Parents array, initialized to all -1, except for start
  long* Parents = new long[n];
  parallel_for(long i=0;i<n;i++) Parents[i] = -1;
  Parents[start] = start;
  vertexSubset Frontier(n,start); //creates initial frontier
  while(!Frontier.isEmpty()){ //loop until frontier is empty
    vertexSubset output = edgeMap(GA, Frontier, BFS_F(Parents));
    Frontier.del();
    Frontier = output; //set new frontier
  }
  Frontier.del();
  free(Parents);
}
```

### Compilation

You can compile your algorithm by adding it to the Ligra `Makefile`. Open up the
`Makefile` in the `apps/` directory in your editor, and change the definition of
`ALL` to:

``` bash
ALL= Tutorial_BFS encoder ... (other apps) ...
```

Now, compile the application by running `make`, which will produce a binary called 
`Tutorial_BFS`.

### Testing

Let's try running our program on one of the test-inputs provided by ligra in the `inputs/`
directory. Note that the `-s` flag tells Ligra that the graph is symmetric (undirected). 

``` 
./Tutorial_BFS -s -start 1 ../inputs/rMatGraph_J_5_100
Running time : 0.000234
Running time : 0.000359
Running time : 0.000243
```

Great! We've successfully implemented a shared memory breadth-first search using Ligra. 
In the remaining tutorials, we will consider more complicated graph algorithms and more
carefully examine the Ligra internals. 
